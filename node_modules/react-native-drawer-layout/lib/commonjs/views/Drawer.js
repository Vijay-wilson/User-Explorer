"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Drawer = Drawer;
var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _useLatestCallback = _interopRequireDefault(require("use-latest-callback"));
var _DrawerProgressContext = require("../utils/DrawerProgressContext");
var _getDrawerWidth = require("../utils/getDrawerWidth");
var _useFakeSharedValue = require("../utils/useFakeSharedValue");
var _Overlay = require("./Overlay");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function Drawer(_ref) {
  let {
    layout: customLayout,
    drawerPosition = 'left',
    drawerStyle,
    drawerType = 'front',
    onClose,
    onTransitionStart,
    onTransitionEnd,
    open,
    overlayStyle,
    overlayAccessibilityLabel,
    renderDrawerContent,
    children,
    style
  } = _ref;
  const windowDimensions = (0, _reactNative.useWindowDimensions)();
  const layout = customLayout ?? windowDimensions;
  const drawerWidth = (0, _getDrawerWidth.getDrawerWidth)({
    layout,
    drawerStyle
  });
  const progress = (0, _useFakeSharedValue.useFakeSharedValue)(open ? 1 : 0);
  React.useEffect(() => {
    progress.value = open ? 1 : 0;
  }, [open, progress]);
  const drawerRef = React.useRef(null);
  const onTransitionStartLatest = (0, _useLatestCallback.default)(() => {
    onTransitionStart?.(open === false);
  });
  const onTransitionEndLatest = (0, _useLatestCallback.default)(() => {
    onTransitionEnd?.(open === false);
  });
  React.useEffect(() => {
    const element = drawerRef.current;
    if (element) {
      element.addEventListener('transitionstart', onTransitionStartLatest);
      element.addEventListener('transitionend', onTransitionEndLatest);
    }
  }, [onTransitionEndLatest, onTransitionStartLatest]);
  const isOpen = drawerType === 'permanent' ? true : open;
  const isRight = drawerPosition === 'right';
  const drawerAnimatedStyle = drawerType !== 'permanent' ? {
    transition: 'transform 0.3s',
    transform: [{
      // The drawer stays in place at open position when `drawerType` is `back`
      translateX: open || drawerType === 'back' ? drawerPosition === 'left' ? 0 : layout.width - drawerWidth : drawerPosition === 'left' ? -drawerWidth : layout.width
    }]
  } : null;
  const contentAnimatedStyle = drawerType !== 'permanent' ? {
    transition: 'transform 0.3s',
    transform: [{
      translateX: open ?
      // The screen content stays in place when `drawerType` is `front`
      drawerType === 'front' ? 0 : drawerWidth * (drawerPosition === 'left' ? 1 : -1) : 0
    }]
  } : null;
  return /*#__PURE__*/React.createElement(_reactNative.View, {
    style: [styles.container, style]
  }, /*#__PURE__*/React.createElement(_DrawerProgressContext.DrawerProgressContext.Provider, {
    value: progress
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    style: [styles.main, {
      flexDirection: drawerType === 'permanent' && !isRight ? 'row-reverse' : 'row'
    }]
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    style: [styles.content, contentAnimatedStyle]
  }, /*#__PURE__*/React.createElement(_reactNative.View, {
    accessibilityElementsHidden: isOpen && drawerType !== 'permanent',
    importantForAccessibility: isOpen && drawerType !== 'permanent' ? 'no-hide-descendants' : 'auto',
    style: styles.content
  }, children), drawerType !== 'permanent' ? /*#__PURE__*/React.createElement(_Overlay.Overlay, {
    open: open,
    progress: progress,
    onPress: () => onClose(),
    style: overlayStyle,
    accessibilityLabel: overlayAccessibilityLabel
  }) : null), /*#__PURE__*/React.createElement(_reactNative.View, {
    ref: drawerRef,
    style: [styles.drawer, {
      width: drawerWidth,
      position: drawerType === 'permanent' ? 'relative' : 'absolute',
      zIndex: drawerType === 'back' ? -1 : 0
    }, drawerAnimatedStyle, drawerStyle]
  }, renderDrawerContent()))));
}
const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1
  },
  drawer: {
    top: 0,
    bottom: 0,
    maxWidth: '100%',
    backgroundColor: 'white'
  },
  content: {
    flex: 1
  },
  main: {
    flex: 1
  }
});
//# sourceMappingURL=Drawer.js.map